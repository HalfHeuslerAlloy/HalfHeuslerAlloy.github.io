<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-03-26T22:44:38+01:00</updated><id>http://localhost:4000/feed.xml</id><entry><title type="html">Optical Mouse Camera</title><link href="http://localhost:4000/electronics,/optical/2023/03/26/Optical-Mouse-Camera.html" rel="alternate" type="text/html" title="Optical Mouse Camera" /><published>2023-03-26T00:00:00+00:00</published><updated>2023-03-26T00:00:00+00:00</updated><id>http://localhost:4000/electronics,/optical/2023/03/26/Optical%20Mouse%20Camera</id><content type="html" xml:base="http://localhost:4000/electronics,/optical/2023/03/26/Optical-Mouse-Camera.html"><![CDATA[<p>We</p>]]></content><author><name></name></author><category term="Electronics," /><category term="Optical" /><summary type="html"><![CDATA[We]]></summary></entry><entry><title type="html">AD9833 Function Generator</title><link href="http://localhost:4000/electronics/2022/08/21/AD9833-Function-generator.html" rel="alternate" type="text/html" title="AD9833 Function Generator" /><published>2022-08-21T00:00:00+01:00</published><updated>2022-08-21T00:00:00+01:00</updated><id>http://localhost:4000/electronics/2022/08/21/AD9833%20Function%20generator</id><content type="html" xml:base="http://localhost:4000/electronics/2022/08/21/AD9833-Function-generator.html"><![CDATA[<p>Instead of simply buying a nice function generator for £100-200 with lots of important features such as variable amplitude, DC offset,  arbitrary functions, etc. We can build one with maybe £25 of materials and a lot more labor without those very useful features.</p>

<p><img src="/assets/AD9833/outside.jpg" alt="Inside the unit" /></p>

<p>The original goal of this project was to see if I could get an Arduino to output a sinewave using IO pins and a voltage ladder. Which did work, but even converting assembly was too slow. Capping out at 100-200KHz, depending on how much resolution you were willing to give up.</p>

<p>I then default to a standard solution of using a dedicated IC for the task. The AD9833 is a programmable waveform generator, with sinusoidal, triangular, and square wave generation at a maximum frequency of 25Mhz. It communicates over a simple SPI interface.</p>

<p><img src="/assets/AD9833/inside.jpg" alt="Inside the unit" /></p>

<p>The internal layout is very simple. The key components are mounted inside removable panels for ease of construction. Importantly the AD9833 is fully enclosed in an EMI shielding box made of a 3D print cover in plenty of aluminum tape. the box probably only has ok shield properties but at 25Mhz and low power that will be enough.</p>

<p>The control software running on the Arduino nano is very simple. Two mechanical and one rotary switch allow digit selection and modifier respectively. It does have a USB port on the back to allow SCPI commands over a simple serial interface. Of course, it doesn’t truly support SCPI commands and only supports two commands in the style of SCPI and nothing else. At some point I should and *IDN and *RST command support.</p>

<p><a href="https://github.com/HalfHeuslerAlloy/AD9833-Function-Generator">Here</a> is a link to GitHub if you want to print out the case and even make it yourself, There isn’t a wiring diagram yet, but the Arduino code will let you know what goes where. I added a voltage regulator and smoothing capacitors.</p>]]></content><author><name></name></author><category term="Electronics" /><summary type="html"><![CDATA[Instead of simply buying a nice function generator for £100-200 with lots of important features such as variable amplitude, DC offset, arbitrary functions, etc. We can build one with maybe £25 of materials and a lot more labor without those very useful features.]]></summary></entry><entry><title type="html">Smallest Physical Implementation of Conway’s Game of Life… Probably</title><link href="http://localhost:4000/electronics/2021/07/30/PIC-MCU-Game-Of-Life.html" rel="alternate" type="text/html" title="Smallest Physical Implementation of Conway’s Game of Life… Probably" /><published>2021-07-30T00:00:00+01:00</published><updated>2021-07-30T00:00:00+01:00</updated><id>http://localhost:4000/electronics/2021/07/30/PIC%20MCU%20Game%20Of%20Life</id><content type="html" xml:base="http://localhost:4000/electronics/2021/07/30/PIC-MCU-Game-Of-Life.html"><![CDATA[<p>Did you know you can get a microcontroller in a 6-pin SOT-23 format? Well several MCU manufactures make them including Microchip’s PIC series, of these PIC10F320 are smaller than a grain of rice and not nearly as tasty. As to be expected you don’t get much in them with only 256 words of program space and 64 bytes of general memory storage. But with an instruction speed of 4MHz we are just fast enough to output PAL/NTSC video by bit bashing a tristate IO pin connected to a couple of resistors. So lets try to implement Conway’s game of life (GOL) in the smallest physical space!</p>

<p>Now we only get 256 words and we’ll need every last bit of it to fit everything in. Even worst, before now I’ve never programmed in assembly and while PICs can be programmed in embedded C like Arduino it is even more unlikely we can fit everything in. Actually this whole project started as a fun way to learn assembly in an interesting and functional environment, and without learning x86 or bricking my PC.</p>

<p>Aficionados of the Atari and other early home game consoles will be familiar with racing the beam. Old game consoles were played on CRTs which have an electron beam racing across the screen and to update the display you had to change video memory at the right time as the beam was moving across the screen. Now the Atari had dedicated hardware to read from a very limited video memory to draw to the screen which left the main processor free to update the video memory and other game logic while that hardware did all the analog output and sync pulse timings to get the video in the right format to work on a CRT.</p>

<p><img src="/assets/PIC_GOL/PAL video.svg" alt="PAL video timings" /></p>

<p>The PICs don’t have such hardware so we need to both race the beam and do bit-bashing to generate the correct waveform. Now each instruction takes 0.25us to execute and the visible portion of each scan line is 52us long, which give us a maximum horizontal resolution of 208 pixels. And that’s only if we use 1 instruction, in most cases, we need multiple instructions to read from some defined video memory and managing loops counters. Again only 256 words so we can’t waste it unrolling loops. Thankfully that won’t matter much as the limited PICs memory space caps our max grid size to 16 by 16 cells.</p>

<p><img src="/assets/PIC_GOL/GOL PIC10F320.svg" alt="Circuit diagram" /></p>

<p>To get just black and white we need to set the video pin to either 0, 0.33V or 1V. While we could use two pins, we can do it with only 1 tristate IO pin. A tristate IO pin has three states high, low or high impedance when set as input. With a voltage divide and knowing that the resistance across the video-in terminal of most TVs is 75 Ohms we can setup a voltage divide to give us 0V, 0.33V and 1V (approximately) and assign them to the low , high impedance and High level respectively.</p>

<p><img src="/assets/PIC_GOL/PIC_MCU_GOL_Inside.jpg" alt="Inside the unit" /></p>

<p>In the end I got this small enough to fit on the end of the plug itself by forgoing the need of a circuit board and directly soldering the SMD resistors and connections to the PIC. A small 3D printer part holds the 3V lithium battery in place. The size of this possibly makes this the smallest physical implementation of GOL (not including the screen). If you know of or have made a smaller one I’d love to see it. Clearly even tiny SOT-23 microcontrollers can do a lot, and in part this project was inspired by <a href="https://youtu.be/PZsWqOuJFKI">this</a> video of a much more impressive tiny video console running on an attiny10.</p>

<iframe width="600vw" height="400vh" src="https://www.youtube.com/embed/dDvYMWH5eS4" frameborder="0" allowfullscreen=""></iframe>

<p>Well here’s it running! The image isn’t quite centered on the display and the internal clock’s instability is likely causing jitter but it does work. Every 32 seconds or so the watchdog timer resets the program and refills the array with random noise. Some of this could be improved either with an external clock and optimizing the code to leave more programming space for extra features. I’ll link the assembly code below if you want to make it yourself or improve on my horrible code!</p>

<p><a href="/assets/PIC_GOL/GameOfLife-16wide.7z">Source Code</a></p>]]></content><author><name></name></author><category term="Electronics" /><summary type="html"><![CDATA[Did you know you can get a microcontroller in a 6-pin SOT-23 format? Well several MCU manufactures make them including Microchip’s PIC series, of these PIC10F320 are smaller than a grain of rice and not nearly as tasty. As to be expected you don’t get much in them with only 256 words of program space and 64 bytes of general memory storage. But with an instruction speed of 4MHz we are just fast enough to output PAL/NTSC video by bit bashing a tristate IO pin connected to a couple of resistors. So lets try to implement Conway’s game of life (GOL) in the smallest physical space!]]></summary></entry><entry><title type="html">Infinite Fractal Plane</title><link href="http://localhost:4000/opengl/fractal/2021/06/06/Infinite-Fractal-plane.html" rel="alternate" type="text/html" title="Infinite Fractal Plane" /><published>2021-06-06T00:00:00+01:00</published><updated>2021-06-06T00:00:00+01:00</updated><id>http://localhost:4000/opengl/fractal/2021/06/06/Infinite%20Fractal%20plane</id><content type="html" xml:base="http://localhost:4000/opengl/fractal/2021/06/06/Infinite-Fractal-plane.html"><![CDATA[<p>This shadertoy script is running a ray matching algorithm with a series of affine transformation to generate fractals. To get an ‘infinite’ fractal plane I use transformations that leave the fractal with cubic symmetry, then using a modulus operation only the x and y coordinates I copy the fractal over an infinite grid. If transformations that generate the fractals are slowly modified over the x-y plane then it allows the surface to slowly change over the surface. This creates a changing fractal landscape to explore.</p>

<iframe width="420" height="315" src="https://www.shadertoy.com/embed/wtj3Wm?gui=true&amp;t=10&amp;paused=true&amp;muted=false" frameborder="0" allowfullscreen=""></iframe>]]></content><author><name></name></author><category term="OpenGL" /><category term="Fractal" /><summary type="html"><![CDATA[This shadertoy script is running a ray matching algorithm with a series of affine transformation to generate fractals. To get an ‘infinite’ fractal plane I use transformations that leave the fractal with cubic symmetry, then using a modulus operation only the x and y coordinates I copy the fractal over an infinite grid. If transformations that generate the fractals are slowly modified over the x-y plane then it allows the surface to slowly change over the surface. This creates a changing fractal landscape to explore.]]></summary></entry><entry><title type="html">Solid State Tesla Coil</title><link href="http://localhost:4000/electronics/2021/06/06/Tesla-Coil.html" rel="alternate" type="text/html" title="Solid State Tesla Coil" /><published>2021-06-06T00:00:00+01:00</published><updated>2021-06-06T00:00:00+01:00</updated><id>http://localhost:4000/electronics/2021/06/06/Tesla%20Coil</id><content type="html" xml:base="http://localhost:4000/electronics/2021/06/06/Tesla-Coil.html"><![CDATA[<p>This is just a quick post about my old Solid State Tesla Coil (SSTC) project. This by far my most dangerous project as it uses high voltage, RF interference and mains voltage! Can produce 10-15cm arcs and scares the hell out of my housemate. Made in the case of an old PC PSU. Uses a few 3d printed parts to hold circuit boards up, support the primary winding and is the tube for the secondary winding. The secondary tube was printed in vase mode and then extra support was added in later for rigidity. Finally the secondary was coated in for generic clear coat varnish to give a little extra protection.</p>

<p><img src="/assets/SSTC/TeslaCoil.jpg" alt="Inside the unit" /></p>

<p>I don’t have a detailed circuit layout you can follow since it was constructed a little ad hoc. It generally follows <a href="https://www.loneoceans.com/labs/sstc2/">this</a> design with a few changes, for instance I had trouble finding a dual mosfet driver with a disable pin for PWM so instead I toggle the power to the IC with a transistor. I also added a fibre optic cable to control the PWM so it can be operated at a safe distance and in the future play some music. I’ll add a video as soon as I can work up the courage to turn it on again, plus I’ll get it to play some music. The primary circuit half H-bridge is currently configured to run at 240V but switching some diodes around can increase that to over 400V (the original plan and spec for these parts). Maybe in the future when I’m a homeowner and have a good isolation transformer I’ll increase it!</p>]]></content><author><name></name></author><category term="Electronics" /><summary type="html"><![CDATA[This is just a quick post about my old Solid State Tesla Coil (SSTC) project. This by far my most dangerous project as it uses high voltage, RF interference and mains voltage! Can produce 10-15cm arcs and scares the hell out of my housemate. Made in the case of an old PC PSU. Uses a few 3d printed parts to hold circuit boards up, support the primary winding and is the tube for the secondary winding. The secondary tube was printed in vase mode and then extra support was added in later for rigidity. Finally the secondary was coated in for generic clear coat varnish to give a little extra protection.]]></summary></entry></feed>